### python中的传值和传引用问题

- 本质都是传引用

```
def modify(a) # 3. 创建一个引用变量 a， 并将其指向传入的实参的引用地址，也即5的那块地址
	a = 7  # 4. 申请一块size（int）地址的空间，将其值设置为7，将 a 其指向这块地址

a = 3   # 1. 申请一块size（int）地址的空间，将其值设置为3， 创建一个变量 a，将其指向这块地址
a = 5    # 2. 申请一块size（int）地址的空间，将其值设置为5，将 a 其指向这块地址
modify(a) 
print(a) # 输出5 # 5. 打印a的地址，这里是第2步中的地址
```

```
def modify(a) # 3. 创建一个引用变量 a， 并将其指向传入的实参的引用地址，也即a的那块地址
	a[0] = 7  # 4. 将a[0]值设置为7

a = [3]   # 1. 申请一块可变地址的空间，放入元素3， 创建一个变量 a，将其指向这块地址
a[0] = 5    # 2. 将a[0]值设置为5
modify(a) 
print(a[0]) # 输出7 # 5. 打印a[0]的值
```

思考，如果是这样就不会改变

```
a = [0]
a = [5]
def modify(a):
    a = [7]

modify(a)
print(a)    # 输出[5]
```



在 Python 中，参数传递给函数的方式可以理解为“传对象引用”。这意味着当你将一个值传递给函数时，你实际上是在传递该值的对象的引用。但是，根据对象是可变（mutable）还是不可变（immutable），行为会有所不同。

#### 不可变对象（Immutable Objects）

对于不可变对象，如整数、浮点数、字符串和元组，一旦创建后就不能改变它们的内容。当你传递一个不可变对象给函数并尝试修改它时，实际上是创建了新的对象，而原始对象保持不变。

```python
def modify_value(x):
    x = 10  # 这里创建了一个新的局部变量 x

a = 5
modify_value(a)
print(a)  # 输出: 5
```

在这个例子中，`modify_value` 函数内部对 `x` 的修改不会影响到外部的 `a` 变量。

#### 可变对象（Mutable Objects）

对于可变对象，如列表、字典、集合等，可以在不改变其身份的情况下修改其内容。如果你在一个函数内修改了一个可变对象，那么这些更改会影响到原始对象，因为它们共享相同的引用。

```python
def modify_list(lst):
    lst.append(4)  # 修改原始列表对象

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # 输出: [1, 2, 3, 4]
```

在这个例子中，`modify_list` 函数内的操作确实改变了 `my_list` 的内容。

#### 传对象引用的特点

- **引用传递**：Python 中所有参数都是按引用传递的，即传递的是对象的引用而不是副本。
- **不可变对象的行为类似于值传递**：由于不能改变不可变对象本身，所以从调用者的角度来看，似乎是在传递值。
- **可变对象允许内部修改**：如果函数内部修改了可变对象，那么这些变化会反映到调用者那里。

#### 复制对象

有时候你可能不希望函数内部对对象的修改影响到原始对象。在这种情况下，你可以使用浅复制（shallow copy）或深复制（deep copy）来创建一个新的独立对象。

- **浅复制**：只复制第一层元素，对于嵌套的对象，仍然共享相同的引用。
- **深复制**：递归地复制整个对象结构，包括所有嵌套的对象。

```python
import copy

original_list = [[1, 2], [3, 4]]
copied_list = copy.deepcopy(original_list)

# 修改 copied_list 不会影响 original_list
copied_list[0][0] = 'changed'
print(original_list)  # 输出: [[1, 2], [3, 4]]
print(copied_list)    # 输出: [['changed', 2], [3, 4]]
```

总结来说，在 Python 中，参数总是以引用的形式传递，但对于不可变对象而言，这种引用传递的效果看起来像是值传递。对于可变对象，则可以直接对其进行修改。